	05:13 <@Mithaldu> tech question, concerning an object system
	05:14 <@Mithaldu> if an attribute is configured to be lazy, and derive its value from a _build_$attribe method, should it ignore 
			 input to its name on the constructor?
	05:16 <@nrr> Mithaldu: you know, that's a really good question.
	05:16 <@nrr> the documentation for moose implies yes.
	05:16 <@Mithaldu> nono
	05:16 <@Mithaldu> disregard documentation
	05:16 <@Mithaldu> think about it purely logically
	05:17 <@nrr> well, okay, how are you taking the definition of 'lazy' here?
	05:17 <@Mithaldu> in the attribute definition there is a flag lazy, that can be 0 or 1
	05:17 <@nrr> yes, but what does that mean semantically?
	05:17 <@Mithaldu> getting to that
	05:18 <@nrr> i mean, given the experience i have with things like haskell and lazy dialects of ML, i'd say that simply constructing 
		     the value whenever it's read is sufficient.
	05:18 <@nrr> your definition may differ.
	05:18 <@Mithaldu> if it's 1, then calling the attribute at runtime will cause it to run a builder sub assigned to it
	05:18 <@Mithaldu> also
	05:18 <@Mithaldu> no wiat, hrm
	05:18 <@Mithaldu> how should lazy interact with required
	05:19 <@Mithaldu> and what would it do on an attribute that has a default sub, but not a builder one
	05:19 <@Mithaldu> i guess points i might have to poke at later
	05:19 <@Mithaldu> but right now let's assume what i said first
	05:20 <@Mithaldu> nrr: yes, basically that
	05:20 <@nrr> the options passed into the constructor should seed the values generated by _build_$attribute
	05:21 <@nrr> that's... about it.
	05:21 <@Mithaldu> sorry, rephrase please?
	05:23 <@nrr> has 'foo' => ( lazy => 1 ) implies that there's a shadow attribute called something like, e.g., __foo_start that is 
		     the value passed in with the constructor. then, sub __build_foo { my ($self, $input) = @_ ; # do stuff here, possibly 
		     with $self->__foo_start, possibly not }
	05:23 <@eevee> are we mooseing
	05:23 <@Mithaldu> no
	05:23 <@Mithaldu> just general oo design
	05:23 <@Mithaldu> nrr:
	05:24 <@Mithaldu> so you think
	05:24 <@eevee> i would not make 'lazy' a first-class property of a general oo system
	05:24 <@nrr> ^
	05:24 <@nrr> i don't particularly like coupling in laziness with the object system.
	05:24 <@eevee> for this reason among others
	05:24 <@nrr> and this is the biggest reason why.
	05:24 <@Mithaldu> new MarpObject( { lazy_attr: "moo" } ); should generate an object where lazy_attr does not carry the value "moo"?
	05:24 <@nrr> haha, for once, eevee and i agree on something.
	05:26 <@eevee> Mithaldu: given that i interpret 'lazy' to mean 'defer the normal calculation of a default', no, that oughta populate 
		       the attr and never run your lazy thing
	05:26 <@nrr> Mithaldu: not directly, no. that should be generated and possibly memoized on the fly.
	05:26  * Mithaldu has no idea what these mean: "a first-class property", "coupling in laziness"
	05:26 <@nrr> god damn it, and i'm talking about 10 levels way too high again.
	05:26 <@Mithaldu> yes, you do
	05:27 <@nrr> laziness should not be a part of your object system.
	05:27 <@nrr> period.
	05:27 <@Mithaldu> pretend we're on simple.wikipedia.org
	05:27 <@nrr> and this ambiguity is possibly the largest reason why. how do you define these concepts?
	05:27 <@eevee> "first-class" means it has direct support from the language
	05:27 <@Mithaldu> nrr: that makes dependency injection of the style i like REALLY hard
	05:27 <@nrr> before you can even begin to discuss them, you need to agree on definitions and agree on how to delineate the concerns.
	05:27 <@nrr> tough?
	05:28 <@Mithaldu> "how do you define these concepts?"
	05:28 <@eevee> why are you designing an oo system
	05:28 <@Mithaldu> you communicate and establish a common base. we've already found out i'm happy to admit when i'm ignorant.
	05:28 <@Mithaldu> eevee: Moose is not usable for my current use case
	05:28 <@Mithaldu> being cgi scripts
	05:29 <@Mithaldu> the load-up time is too much
	05:29 <@eevee> why are you writing cgi scripts
	05:29 <@Mithaldu> because $work
	05:29 <@Mithaldu> it's a long story
	05:29 <@Mithaldu> (part of it is also that apache is fucking shit)
	05:29 <@eevee> http://search.cpan.org/~ingy/Mo-0.30/lib/Mo.pod ??
	05:29 <@Mithaldu> anyhow
	05:30 <@Mithaldu> i tried working with Mo
	05:30 <@Mithaldu> but it does not support enough stuff
	05:30 <@Mithaldu> and trying to change it is hell
	05:30 <@Mithaldu> i did write a nifty auto-golfer for it though!
	05:30 <@eevee> this seems like a lot of effort to solve the wrong problem
	05:31 <@Mithaldu> Mouse is not very desirable since its compiled and universally hated
	05:31 <@nrr> Mithaldu: look at implementing a couple of design patterns using functors (or, as some folks call them, function 
		     objects) as a compromise.
	05:31 <@nrr> don't try to kluge this into the object system directly.
	05:31 <@Mithaldu> so i settled on using Moo, which is fine, since Web::Simple already uses it
	05:31 <@eevee> what about Moo
	05:31 <@eevee> ok
	05:31 <@Mithaldu> nrr: honestly?
	05:31 <@Mithaldu> eevee is doing a better job at communicating right nwo :P
	05:32 <@Mithaldu> eevee: its implementation of lazy differs from Moose in one single detail
	05:32 <@Mithaldu> if you set it, it ignores constructor parameters
	05:32 <@eevee> write your own custom accessors then
	05:33 <@eevee> or accessor factory
	05:33 <@Mithaldu> nah, then i'd be writing my own object system
	05:33 <@Mithaldu> and i've already got a foot in to get that changed
	05:33 <@eevee> or fix your damn runtime and use the real thing
	05:33 <@eevee> what
	05:33 <@Mithaldu> i'm just curious what other people think about this
	05:34 <@Mithaldu> but i guess nobody cares, so meh
	05:36 <@nrr> well, like, i've never really had to consider it from an OO perspective before.
	05:36 <@nrr> in functional land, the application is dead simple.
	05:37 <@nrr> it's mostly that i've never considered this to be a problem worth investigating and have never seen the purpose.
	05:37 <@nrr> i'd have to think about it.
	05:37 <@nrr> just like method references.
	05:38 <@nrr> i've probably only ever run into the case where i've needed to use one once or twice ever.
	05:38 <@Mithaldu> assume you can simple point to the method and call it, by name
	05:38 <@Mithaldu> anyhow
	05:38 <@Mithaldu> this was really just meant to be a shoot the shit thing about the interaction of constructor and lazy
	05:38 <@Mithaldu> not a thesaurus shootout
	05:38 <@nrr> my opinion right now is "don't"
	05:39 <@nrr> that's pretty much what it boils down to
	05:39 <@Mithaldu> well hurf durf
	05:39 <@eevee> i wish pyramid's @reify were stdlib
	05:39 <@Mithaldu> that statement is literally content-less
	05:40 <@eevee> @reify
	05:40 <@eevee> def foo(self):
	05:40 <@eevee>   print "in foo"
	05:40 <@eevee>   return 3
	05:40 <@Mithaldu> should there not be a lazy? not a constructor? not a builder?
	05:40 <@Mithaldu> welp welp
	05:40 <@eevee> print obj.foo  # "in foo", 3
	05:40 <@eevee> print obj.foo  # 3
	05:40 <@nrr> Mithaldu: both eevee and i mentioned that we thought the whole notion of baking 'lazy' into the object system was a bit 
		     of a bad idea.
	05:40 <@Mithaldu> that looks like a builder to me
	05:40 <@nrr> where is this not clear?
	05:41 <@Mithaldu> nrr: i said something a long while ago
	05:41 <@Mithaldu> i'll say it again
	05:41 <@Mithaldu> very relevant
	05:41 <@Mithaldu> "saying 'don't do this' without also saying 'DO do this', is beyond useless"
	05:42 <@nrr> i agree, but i'm afraid my lack of 'DO do this' stems from the fact that i've never had to consider this problem 
		     before.
	05:42 <@nrr> forgive me for being a bit braindead.
	05:42 <@Mithaldu> "not right now" is also a nice answer along the lines of "i don't know" :P
	05:43 <@nrr> my solution earlier was to implement the lazy functionality using functors and by using certain design patterns.
	05:43 <@nrr> i don't have names for them right now either.
	05:43 <@Mithaldu> i frankly don't understand what you mean by that
	05:43 <@nrr> it's pretty much just a class you can vaguely call like a function.
	05:43 <@Mithaldu> do you mean that you consider lazy to be a combination of features?
	05:44 <@nrr> i mean that laziness is something distinct from OO.
	05:44 <@nrr> it needs to be treated as such.
	05:44 <@Mithaldu> no can do
	05:44 <@nrr> that's a fundamental problem.
	05:44 <@Mithaldu> i don't want to have to get a university degree to have a database handle opened at runtime or provided by 
			 constructor, depending on my mood while coding
	05:45 <@eevee> write a method yourself or fix your deployment
	05:45 <@Mithaldu> anyhow, again
	05:46 <@Mithaldu> i wasn't looking for a solution, since i have that already
	05:48 <@Mithaldu> (also, the object system is meant to prevent me from having to write duplicate code)
	05:49 <@eevee> once you've written the method once, you can write a factory
	05:51 <@Mithaldu> use MooX::LazyAttrMaker;
	05:51 <@Mithaldu> has lazy_attr( 'marp' );
	05:51 <@Mithaldu> how's that better than doing it in the object system?
	05:52 <@Mithaldu> (lazy_attr() returns the definition for the constructor input and exports a sub doing the laziness)
